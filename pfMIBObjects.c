/* This file was generated by mib2c and is intended for use as a mib module
   for the ucd-snmp snmpd agent. */


#ifdef IN_UCD_SNMP_SOURCE
/* If we're compiling this file inside the ucd-snmp source tree */


/* This should always be included first before anything else */
#include <config.h>


/* minimal include directives */
#include "mibincl.h"
#include "util_funcs.h"


#else /* !IN_UCD_SNMP_SOURCE */


#include <ucd-snmp/ucd-snmp-config.h>
#include <ucd-snmp/ucd-snmp-includes.h>
#include <ucd-snmp/ucd-snmp-agent-includes.h>


#endif /* !IN_UCD_SNMP_SOURCE */


#include "OpenBSD.h"


/* 
 * OpenBSD_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */


oid OpenBSD_variables_oid[] = { 1,3,6,1,4,1,64512 };


/* 
 * variable4 OpenBSD_variables:
 *   this variable defines function callbacks and type return information 
 *   for the OpenBSD mib section 
 */


struct variable4 OpenBSD_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */
#define   RUNNING               1
  { RUNNING             , ASN_INTEGER   , RONLY , var_OpenBSD, 3, { 1,1,1 } },
#define   UPTIME                2
  { UPTIME              , ASN_TIMETICKS , RONLY , var_OpenBSD, 3, { 1,1,2 } },
#define   DEBUG                 3
  { DEBUG               , ASN_INTEGER   , RONLY , var_OpenBSD, 3, { 1,1,3 } },
#define   HOSTID                4
  { HOSTID              , ASN_OCTET_STR , RONLY , var_OpenBSD, 3, { 1,1,4 } },
#define   MATCH                 5
  { MATCH               , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,2,1 } },
#define   BAD-OFFSET            6
  { BAD-OFFSET          , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,2,2 } },
#define   FRAGMENT              7
  { FRAGMENT            , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,2,3 } },
#define   SHORT                 8
  { SHORT               , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,2,4 } },
#define   NORMALIZE             9
  { NORMALIZE           , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,2,5 } },
#define   MEMORY                10
  { MEMORY              , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,2,6 } },
#define   COUNT                 11
  { COUNT               , ASN_UNSIGNED  , RONLY , var_OpenBSD, 3, { 1,3,1 } },
#define   SEARCHES              12
  { SEARCHES            , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,3,2 } },
#define   INSERTS               13
  { INSERTS             , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,3,3 } },
#define   REMOVALS              14
  { REMOVALS            , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,3,4 } },
#define   NAME                  15
  { NAME                , ASN_OCTET_STR , RONLY , var_OpenBSD, 3, { 1,4,1 } },
#define   IPBYTESIN             16
  { IPBYTESIN           , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,4,2 } },
#define   IPBYTESOUT            17
  { IPBYTESOUT          , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,4,3 } },
#define   IPPKTSINPASS          18
  { IPPKTSINPASS        , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,4,4 } },
#define   IPPKTSINDROP          19
  { IPPKTSINDROP        , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,4,5 } },
#define   IPPKTSOUTPASS         20
  { IPPKTSOUTPASS       , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,4,6 } },
#define   IPPKTSOUTDROP         21
  { IPPKTSOUTDROP       , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,4,7 } },
#define   IP6BYTESIN            22
  { IP6BYTESIN          , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,4,8 } },
#define   IP6BYTESOUT           23
  { IP6BYTESOUT         , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,4,9 } },
#define   IP6PKTSINPASS         24
  { IP6PKTSINPASS       , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,4,10 } },
#define   IP6PKTSINDROP         25
  { IP6PKTSINDROP       , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,4,11 } },
#define   IP6PKTSOUTPASS        26
  { IP6PKTSOUTPASS      , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,4,12 } },
#define   IP6PKTSOUTDROP        27
  { IP6PKTSOUTDROP      , ASN_COUNTER64 , RONLY , var_OpenBSD, 3, { 1,4,13 } },

};
/*    (L = length of the oidsuffix) */


/*
 * init_OpenBSD():
 *   Initialization routine.  This is called when the agent starts up.
 *   At a minimum, registration of your variables should take place here.
 */
void init_OpenBSD(void) {


  /* register ourselves with the agent to handle our mib tree */
  REGISTER_MIB("OpenBSD", OpenBSD_variables, variable4,
               OpenBSD_variables_oid);


  /* place any other initialization junk you need here */
}


/*
 * var_OpenBSD():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_OpenBSD(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{


  /* variables we may use later */
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;


  if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;


  /* 
   * this is where we do the value assignments for the mib results.
   */
  switch(vp->magic) {


    case RUNNING:
        
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case UPTIME:
        
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case DEBUG:
        
        long_ret = 0;
        return (unsigned char *) &long_ret;

    case HOSTID:
        
        *string = 0;
        *var_len = strlen(string);
        return (unsigned char *) string;

    case MATCH:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case BAD-OFFSET:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case FRAGMENT:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case SHORT:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case NORMALIZE:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case MEMORY:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case COUNT:
        
        ulong_ret = 0;
        return (unsigned char *) &ulong_ret;

    case SEARCHES:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case INSERTS:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case REMOVALS:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case NAME:
        
        *string = 0;
        *var_len = strlen(string);
        return (unsigned char *) string;

    case IPBYTESIN:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case IPBYTESOUT:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case IPPKTSINPASS:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case IPPKTSINDROP:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case IPPKTSOUTPASS:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case IPPKTSOUTDROP:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case IP6BYTESIN:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case IP6BYTESOUT:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case IP6PKTSINPASS:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case IP6PKTSINDROP:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case IP6PKTSOUTPASS:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;

    case IP6PKTSOUTDROP:
        
        c64.high = 0;
        c64.low = 0;
        *var_len = sizeof(c64);
        return (unsigned char *) &c64;


    default:
      ERROR_MSG("");
  }
  return NULL;
}







